# Operators

## Ranges

There were many options for the range operator syntax. Initially, it was thought it should be inclusive of the start value and exclusive of the end value. This would make the common C `for` loop case the default. However, it was very difficult to come up with a good syntax for the inclusive case. After looking at Swift and reviewing the [operators used by other languages for range](http://rigaux.org/language-study/syntax-across-languages/VrsDatTps.html#VrsDatTpsRng) this was changed. It appears most languages use `..` to be inclusive of both ends. This then opens up `..<`, `<..` and `<..<` for ranges exclusive of their end values. This syntax was inspired by the Swift `..<` operator for half open ranges. It was decided that C style for loops should now be rare enough that it isn't an issue that they have a longer, more awkward syntax.

## Accept Operator

For years, an accept operator had been planned. This was to be the symbol `..` and would be used as the accept method in the visitor pattern. It would also be a way to take a function pointer and use it like a method on its first argument type. When Adamant was being designed, having a ranger operator was found to be important and `..` has become a defacto range operator. It is a good fit for this. While Swift uses `...` for this, it seems like that may be needed for something like list expansion. For a while it was thought that `..` could be used as both the accept operator and the range operator since the operand types would be distinct. However, those operators need to have radically different precedence. The range operator should have a fairly low precedence while the accept operator has a high precedence like member access does. Then it was thought these cases could be distinguished syntactically by looking for an invocation afterward. However, `x..y()` could equally mean that `x` accepts the visitor `y` or that a range is being constructed from `x` to the result of `y()`.
